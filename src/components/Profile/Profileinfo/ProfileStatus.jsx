import s from './ProfileStatus.module.css'
import React from 'react';


class ProfileStatus extends React.Component  {
    
    

    onStatusChange = (e) => { // сюди нам приходить е, завдяки е ми можемо дізнатись яке значення вписується в строці інпута
        // і потім ми його сетаємо в стейт за допомогою вбудованого метода локального стейта setState(), якому потрібно передати обєкт 
        this.setState({
            status: e.currentTarget.value
        })

   }

   componentDidUpdate(prevProps, prevState) { // метод який спрацьовує коли компонента перемальовується
    // бо міняються пропри або локальний стейт 
    // Тому якщо наш локальний статус є такий самий як з пропсів, то не треба перемальовувати
    // цей метод викликається щоразу після рендеру і знову дивиться це правило, тому ми не можемо тут просто 
    //оновлювати через setState() 
    // бо буде ціклично оновлювати і зависне. Тому ставимо умову, і після апдейта умова вже не буде виконуватись і ми не будемо 
    //сюди попадати 

    
       if (prevProps.status !== this.props.status) {
           this.setState({
               status: this.props.status
           })
       }

   }

    state = { // наш локальний стейт
        editMode: false,
        status: this.props.status
       
    }

    activateEditMode = () => {
        this.setState(
            {editMode: true}
        ) // спеціальний метод який береться з React.Component і змінює наш локальний стейт
        // в нього ми передаємо обєкт, властивості якого перезапишуть ті властивості які були в стейті
    }
    deactivateEditMode = () => {
        this.setState(
            {editMode: false}
        )
        this.props.updateStatus(this.state.status) // після відведення мишки ми виключаємо едітмод і шлемо на сервер новий статус
    }

    

    render() {
// якщо не забіндити то буде шукати властивості в спані і бачити їх як undefined, а тут ми йому кажемо працювати 
// з нашим головнийм this класу. Знайди в класі метод activateEditMode а не в setState. 
// Але ми змінили синтаксис методу обєкта з звичайного activateEditMode () {}
// на стрілкову ф-ю і тому нам біільше не треба біндити цей метод до this
        

        return ( 

            // тут будемо показувати статус з прпсів, бо ще сервер не оновився
            <div >
                {!this.state.editMode &&
                <div> 

                    
                    <span onDoubleClick={this.activateEditMode} className={s.text}>{this.props.status}</span> 
                    
                </div>
    }

                {this.state.editMode &&
                    
                    <div>
                    <input onChange={this.onStatusChange}
                    autoFocus={true} onBlur={this.deactivateEditMode} type="text" value={this.state.status} // 
                    // будемо показувати статус не з пропсівського статуса і з локального стейтівського
                    />
                </div>
                }
            </div>


    

)
    
}
}

export default ProfileStatus;



// при завантаженні статус береться зі стору і показується в спані
// при введенні в інпут статус зберігається в локальний стейт, через його метод setState. Він 
// заповнюється побуквенно через onStatusChange(який змінює локальний стейт) і потім він ж відображається в input через атрибут value



// при першому рендері компоненти ми кажемо щоб вона показала нам статус з пропсів стора, але ми також 
// паралельно робили запит на сервак в я комусь контейнері який сетав статус в сторі і деколи виникала ситуація що результат
// запиту ще не засетався і якийсь час показувало дефолтне значання з стору (пусту строку), бо компонента вже вмонтувалась
// метод componentDidMount() спрацював


// і тут за деякий час приходить новий статус з стора(бо оновився після відповіді сервера)
// і саме тому ми написали метод componentDidUpdate() який спрацьовує щоразу коли щось оновилось пропси які нам закидують або
// локальний стейт якийсь
// і тому ми писали перевірку 

// componentDidUpdate(prevProps, prevState) { // цей метод використовуєтся здебільшого для синхтонізації
    
//        if (prevProps.status !== this.props.status) { // якщо пропсах були одні а стали інші, то значить що нам 
// їх треба засетати в локальний стейт (його видно в інпут) був синхронізований і 
// щоб змінилась картинка відповідно до нових пропсів 
//            this.setState({
//                status: this.props.status
//            })
//        }

//    }
